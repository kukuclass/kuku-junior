### 作业1: 了解箭头函数和普通函数的区别（react onClick事件）

箭头函数：

```
let fun = () => {
    console.log('lalalala');
}
```

普通函数：

```
function fun() {
    console.log('lalla');
}
```

- **箭头函数是匿名函数，不能作为构造函数，不能使用new**
- **箭头函数不绑定arguments，取而代之用rest参数...解决**

```
function A(a){
  console.log(arguments);
}
A(1,2,3,4,5,8);  //  [1, 2, 3, 4, 5, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]


let B = (b)=>{
  console.log(arguments);
}
B(2,92,32,32);   // Uncaught ReferenceError: arguments is not defined


let C = (...c) => {
  console.log(c);
}
C(3,82,32,11323);  // [3, 82, 32, 11323]
```



- **箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值**

```
var obj = {
  a: 10,
  b: () => {
    console.log(this.a); // undefined
    console.log(this); // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}
  },
  c: function() {
    console.log(this.a); // 10
    console.log(this); // {a: 10, b: ƒ, c: ƒ}
  }
}
obj.b(); 
obj.c();

//作用域为函数时
var obj = {
  a: 10,
  b: function(){
    console.log(this.a); //10
  },
  c: function() {
     return ()=>{
           console.log(this.a); //10
     }
  }
}
obj.b(); 
obj.c()();
```

- **箭头函数通过 call()  或   apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。**

- **箭头函数没有原型属性**
- **箭头函数不能当做Generator函数,不能使用yield关键字**

---

### 作业2: 预习css transform / transition / animation

css动画效果共3个部分：变形、过渡、动画

#### 1.css变形：transform

- translate()方法：位移

  - translateX(x)：元素仅在水平方向移动（X轴移动）；
  - translateY(y)：元素仅在垂直方向移动（Y轴移动）；
  - transklate(x,y)：元素在水平方向和垂直方向同时移动（X轴和Y轴同时移动）；

  ```
   transform:translateX(30px);
  ```

  

- scale()方法：缩放

  - scaleX(x)：元素仅水平方向缩放（X轴缩放）;

    说明：x表示元素沿着水平方向（X轴）缩放的倍数，如果大于1就代表放大；如果小于1就代表缩小。

  - scaleY(y)：元素仅垂直方向缩放（Y轴缩放）;

  - scale(x,y)：元素水平方向和垂直方向同时缩放（X轴和Y轴同时缩放）；

  ```
   transform:scaleX(30px);
  ```



- rotate()方法：旋转

  rotate()方法来将元素相对中心原点进行旋转。

  transform：rotate(度数)      单位为deg

  ​	说明：如果度数为正，则表示元素相对原点中心顺时针旋转；如果度数为负，则表示元素相对原点中心进行逆时针旋转。

  ```
   transform:rotate(30deg);
  ```



- skew()方法：倾斜

  - skewX(x)：使元素在水平方向倾斜（X轴倾斜）；

    会保持高度，沿着X轴倾斜

  - skewY(y)：使元素在垂直方向倾斜（Y轴倾斜）；

    会保持宽度，沿着Y轴倾斜

  - skew(x,y)：使元素在水平方向和垂直方向同时倾斜（X轴和Y轴同时倾斜）；

    会先按照skewX()方法倾斜，然后按照skewY()方法倾斜

  ```
  transform:skewX(30deg);
  ```



- transform-origin属性：改变元素变形时的中心原点位置

  ​		transform-origin属性取值有2种：一种是采用长度值，另外一种是使用关键字。长度值一般使用百分比作为单位，很少使用px、em等作为单位。

  ```
  transform-origin:right center;
  ```



#### 2.css过渡：transition

​		使用transition属性来将元素的某一个属性从“**一个属性值**”在指定的时间内平滑地过渡到“**另外一个属性值**”来实现动画效果

transition属性是一个复合属性，主要包含4个子属性：

- **transition-property**：对元素的哪一个属性进行操作；(CSS属性名)

- **transition-duration**：过渡的持续时间；（单位s）

- **transition-timing-function**：过渡使用的方法（函数）；

  ​	属性取值共有5种：

  - ease：过渡速度由快到慢
  - linear：线性变化，恒速
  - ease-in：加速
  - easr-out：减速
  - ease-in-out：先加速再减速

- **transition-delay**：可选属性，指定过渡开始出现的延迟时间；

```
 transition:background-color 1s linear;
 
 transition-property:background-color;
 transition-duration:1s ;
 transition-timing-function:linear;
 transition-delay:0s;
```



#### 3.css动画：animation

​		animation属性则通过定义多个关键帧以及定义每个关键帧中元素的属性值来实现复杂的动画效果。

使用animation属性定义CSS3动画需要2步：

​	（1）定义动画；

​	（2）调用动画；

```
@keyframes mycolor
        {
            0%{background-color:red;}
            30%{background-color:blue;}
            60%{background-color:yellow;}
            100%{background-color:green;}
        }
div:hover
        {
            animation-name:mycolor;
            animation-duration:5s;
            animation-timing-function:linear;
        }
```

- **@keyframe**

  在使用动画之前，我们必须使用@keyframes规则定义动画

  ```
  @keyframes 动画名
  {
      0%
      {
          ……
      }
      ……
      100%
      {
           
      }
  }
  ```

  

>  说明：
>
> ​		0%表示动画的开始，100%表示动画的结束。0%和100%是必须的，不过在一个@keyframes规则中可以由多个百分比构成，每一个百分比都可以定义自身的CSS样式，从而形成一系列的动画效果。
>
> ​		使用@keyframes规则时，如果仅仅只有0%和100%这两个百分比的话，这时0%和100%还可以使用关键词from和to来代表，其中0%对应的是from，100%对应的是to。

- **animation-name 属性**

  ```
  animation-name：动画名;
  ```

  animation-name 调用的动画名需要和@keyframes规则定义的动画名称完全一致

- **animation-duration属性**：持续时间

- **animation-timing-function属性**

  ​	设置动画的播放方式

  ​	取值跟transition-timing-function属性取值一样，共有5种

- **animation-delay属性**：延迟时间

- **animation-iteration-count属性**：定义动画的播放次数

  属性取值有2种：

  ​	（1）正整数；

  ​	（2）infinite；

  ​		animation-iteration-count属性默认值为1。也就是默认情况下，动画从开始到结束只播放一次。“animation-iteration-count:n”表示动画播放n次，n为正整数；

  ​		当animation-iteration-count属性取值为infinite时，动画会无限次地循环播放。

- **animation-direction属性**：定义动画的播放方向

  | 属性值    | 说明                                                         |
  | --------- | ------------------------------------------------------------ |
  | normal    | 每次循环都向正方向播放（默认值）                             |
  | reverse   | 每次循环都向反方向播放                                       |
  | alternate | 播放次数是奇数时，动画向原方向播放；播放次数是偶数时，动画向反方向播放 |

- **animation-play-state属性**：定义动画的播放状态

  ​	取值：running和paused。

- **animation-fill-mode属性**：定义在动画开始之前和动画结束之后发生的事情

| 属性值    | 说明                                         |
| --------- | -------------------------------------------- |
| none      | 动画完成最后一帧时会反转到初始帧处（默认值） |
| forwards  | 动画结束之后继续应用最后的关键帧位置         |
| backwards | 会在向元素应用动画样式时迅速应用动画的初始帧 |
| both      | 元素动画同时具有forwards和backwards效果      |

---

### 作业3: 了解rem布局

#### 1.rem是什么

rem是css3新增的相对单位，相对于根元素`<html>`。

这个单位集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。

rem换算：rem = px/(html的px值)

> 浏览器默认的 html `font-size=16px`， 这样如果我们需要设置字体的大小为12px, 通过计算可知 12 / 16 = 0.75；因此只需要设置 `font-size= 0.75rem`。
>
> 为了计算方便，我们可以设置html `font-size=10px` 或者 `font-size=62.5%`，这样设置12px字体的时候就只需要设置 `font-size=1.2rem`

#### 2.rem布局原理

rem布局的本质是等比缩放。

面试中关于rem的题，如下，问s1、s2、s5、s6的font-size和line-height分别是多少px

```
<div class="p1">
	<div class="s1">1</div>
  	<div class="s2">1</div>
</div>
<div class="p2">
	<div class="s5">1</div>
  	<div class="s6">1</div>
</div>


.p1 {font-size: 16px; line-height: 32px;}
.s1 {font-size: 2em;}
.s2 {font-size: 2em; line-height: 2em;}

.p2 {font-size: 16px; line-height: 2;}
.s5 {font-size: 2em;}
.s6 {font-size: 2em; line-height: 2em;}

//答案：
p1：font-size: 16px; line-height: 32px
s1：font-size: 32px; line-height: 32px
s2：font-size: 32px; line-height: 64px 

p2：font-size: 16px; line-height: 32px
s5：font-size: 32px; line-height: 64px
s6：font-size: 32px; line-height: 64px 
```

- s1 rem作为字体单位，相对于父元素字体大小；line-height继承父元素计算值

- s2 rem作为行高单位时，相对于自身字体大小

- p2 `line-height: 2`自身字体大小的两倍

- s5 数字无单位行高，继承原始值，s5的line-height继承的2，自身字体大小的两倍

- s6 无需解释

  

rem取值分为两种情况，设置在根元素时和非根元素时，举个例子

```css
/* 作用于根元素，相对于原始大小（16px），所以html的font-size为32px*/
html {font-size: 2rem}

/* 作用于非根元素，相对于根元素字体大小，所以为64px */
p {font-size: 2rem}
```

---

### 作业4: 了解css @media 媒体查询

@media 可以针对不同的屏幕尺寸设置不同的样式。页面布局分别适应移动端、pc端等，在调整浏览器的大小，页面会根据媒体的宽度和高度来重新布置样式。

 `@media`  可用于基于一个或多个 媒体查询 的结果来应用样式表的一部分。 使用它，您可以指定一个媒体查询和一个CSS块，当且仅当该媒体查询与正在使用其内容的设备匹配时，该CSS块才能应用于该文档。  

#### 1. 针对不同的媒体设备外部链入不同的 stylesheets（外部样式表）

```html
<link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css">
```

​		定义媒体查询的部分放在`<link>`标签内，用**media**属性标注，media="  媒体类型  and/not/only（媒体特性）"

>例：表示外部样式iphone.css适用于最大设备宽度为480px

```
<link rel="stylesheet" media="screen and (max-device-width:480px)" href="iphone.css" />
```



#### 2.css中引入

```css
@media mediatype and/not/only (media feature) 
{   
    CSS-Code；
}
```

- **mediatype媒体类型**：
  - all 所有媒体
  - braille 盲文触觉设备
  - embossed 盲文打印机
  - print 手持设备
  - projection 打印预览
  - screen 彩屏设备
  - speech '听觉'类似的媒体类型
  - tty 不适用像素的设备
  - tv 电视
- **逻辑运算符**
  - not：用来排除某种设备
  - only：用以指定某特定媒体设备
  - all：适用于所有的设备类型
  - and：媒体查询中使用来连接多种媒体特性,一个媒体查询中可以包含0或多个表达式，表达式可以是0或多个关键字，以及一种媒体类型

例子：

> 当屏幕宽度小于678px的时候，.box类的背景颜色为红色

```
@media screen and （max-width:678px）{

.box {

	background-color:red;

}}
```

> 当屏幕宽度在678px到992px之间时，.box类的背景颜色为红色

```
@media screen and （min-width:678px） and (max-width:992px){

.box {

	background-color:red;

}}
```

> only
>
> 只对screen类型起作用，对于print等其他设备不起作用

```  
@media only screen and （max-width:678px）{

.box {

	background-color:red;

}}
```

>  not就是对于除了该媒体类型的其他类型起作用
>
> 例子：对于screen类型不起作用，其他类型起作用

```
@media not screen and （max-width:678px）{

.box {

	background-color:red;

}}
```

---



### 作业5: 了解html5 history API，了解history mode和 hash mode的区别，学习react-router

#### 1.history API

History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL。

DOM `window`对象通过`history`对象提供了对浏览器历史的访问。它暴露了很多有用的方法和属性，允许你在用户浏览历史中向前和向后跳转，同时，从HTML5开始提供了对history栈中内容的操作。

- 在history中跳转

  使用`back()`，`forward()`，`go()`方法来完成在用户历史记录中向后和向前跳转。

  ```
  // 在history中向后跳转
  window.history.back();
  window.history.go(-1);
  
  // 向前跳转
  window.history.forward();
  window.history.go(1);
  
  // 当前页
  window.history.go(0);
  ```

- 添加和修改历史记录中的条目 (**pushState()**和**replaceState()**)

  ​		HTML5引入了`history.pushState()`和`history.replaceState()`方法，他们分别可以添加和修改历史记录条目。这些方法通常与`window.onpopstate`配合使用。

  - **pushState()方法**

    ​	`pushState()`需要三个参数：一个状态对象，一个标题（目前被忽略）和一个URL（可选的）。

    - 状态对象

      ​		状态对象state是一个js对象，通过pushState()创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本。

      ​		状态对象可以是能被序列化的任何东西。原因在于火狐将状态对象保存在用户的磁盘上，以便用户重启浏览器时使用，我们规定了状态对象在序列化表示后有640k的大小限制。如果你给pushState()方法传了一个序列化后大于640k状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用sessionStorage以及localStorage

    - 标题

      ​		火狐目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的state传递一个短标题。

    - URL

      ​		该参数定义了新的历史URL记录。注意，调用pushState()后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径那么它将被作为相对于当前URL处理。新URL必须与当前URL同源，否则pushState()会抛出一个异常。该参数是可选的，缺省为当前URL。

      ​	注意：`pushState()`不会触发`hashchange`事件，即是是新的URL与旧的URL仅哈希不同也不会触发。

      

    例子：

    > 假设有以下几个文件
    >
    > 假设在http://demo.com/foo.html中执行了一下js代码：

    ```
    var stateObj = { foo: 'bar' };
    window.history.pushState(stateObj, 'page 2', 'bar.html');
    ```

    > 这将使浏览器地址栏显示为http://demo.com/bar.html，但并不会导致浏览器加载bar.html,甚至不会检查bar.html是否存在。如下图所示：

    ![图1](https://images2017.cnblogs.com/blog/1012606/201712/1012606-20171226141227807-736262084.png)

    > 现在假设用户又访问了下面的链接http://demo.com/other.html，然后点击了返回按钮。此时，地址栏将显示http://demo.com/bar.html，同时页面会触发popstate事件，事件对象state中包含了`stateObj`的一份拷贝。页面本身与`foo.html`一样，尽管其在`popstate`事件中可能会修改自身内容。

    > 如果我们再次点击返回按钮，页面URL会变为http://demo.com/foo.html，文档对象document会触发另外一个`popstate`事件，这一次的事件对象state object为null。这里也一样，返回并不改变文档的内容，尽管文档在接受`popstate`事件时可能会改变自己的内容，其内容仍与之前的展现一致。

    ​	

  - **replaceState()方法**

  例子：

> 假设http://demo.com/foo.html执行了如下js代码：

```
var stateObj = { foo: 'bar' };
window.history.pushState(stateObj, 'page 2', 'bar.html');
```

> 假设接着执行了如下代码：

```
window.history.replaceState(stateObj, 'page 3', 'bar2.html');
```

> 这将会导致地址栏显示http://demo.com/bar2.html，但是浏览器并不会去加载bar2.html甚至不需要检查bar2.html是否存在。

![图2](https://images2017.cnblogs.com/blog/1012606/201712/1012606-20171226145038807-178310500.png)

> 假设现在用户重新导向了http://demo.com/other.html，然后点击了回退按钮，这里地址栏会显示http://demo.com/bar2.html，再次点击回退，地址栏显示foo.html完全跳过了bar.html

**popstate事件**

每当活动的历史记录项发生变化时，`popstate`事件都会被传递给window对象。如果当前活动的历史记录项是被`pushState`创建的，或者是由`replaceState`改变的，那么`popstate`事件的状态属性`state`会包含一个当前历史记录状态对象的拷贝。

**获取当前状态**

页面加载时，或许会有个非null的状态对象。这是有可能发生的，你可以读取当前历史记录项的状态对象state，而不必等待`popstate`事件，只需要这样使用`history.state`属性：

```
var currentState = history.state;
```



#### 2.history mode和 hash mode的区别

- **hash模式**：

  ​	hash：即地址栏 URL 中的 `#` 符号

  ​	比如这个 URL：`http://www.abc.com/#/hello`，hash 的值为 `#/hello`。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。

  ​	hash模式背后的原理是`onhashchange`事件,可以在window对象上监听这个事件，hash发生变化的url都会被浏览器记录下来：

  ```
  window.onhashchange = function(event){
       console.log(event.oldURL, event.newURL);
  }
  ```

- **history模式**：

  ​	`pushState()` 和 `replaceState()` 方法，这两个方法应用于浏览器的历史记录栈，在当前已有的 `back`、`forward`、`go` 的基础之上，它们提供了对历史记录进行修改的功能。通过pushstate把页面的状态保存在state对象中，当页面的url再变回这个url时，可以通过event.state取到这个state对象，从而可以对页面状态进行还原

  ​	只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。

  ```
  history.pushState({color:'red'}, 'red', 'red')
  history.back();
  setTimeout(function(){
      history.forward();
   },0)
  window.onpopstate = function(event){
       console.log(event.state)
       if(event.state && event.state.color === 'red'){
             document.body.style.color = 'red';
        }
  }
  ```

  通过history api，我们丢掉了丑陋的#。它也有个毛病：不怕前进，不怕后退，就怕**刷新**，**f5**，（如果后端没有准备的话）,因为刷新是实实在在地去请求服务器。

  

- **区别**：

  - `hash` 模式下，仅 `hash` 符号之前的内容会被包含在请求中，如 `http://www.abc.com`，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。
  - `history` 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 `http://www.abc.com/book/id`。如果后端缺少对 `/book/id` 的路由处理，将返回 404 错误。